import json
from datetime import datetime
from pydantic import ValidationError
from typing import List
from services.event_dispatcher import EventDispatcher, Event
from services.base_service import BaseService
from models.system_model import SystemModel
from models.schemas import LevelReading, TankLevelPayload
from utils.logger import get_logger
from .base_controller import BaseController
from config import (
    L1_THRESHOLD,
    L2_THRESHOLD,
    T1_DURATION,
    T2_TIMEOUT,
    MAX_READINGS
)

logger = get_logger(__name__)


class SystemController(BaseController):
    """
    System controller implementing business logic for Smart Tank Monitoring.
    
    Transport-agnostic: communicates via events only, never directly with services.
    Services can be swapped (Serial â†” MQTT) without changing controller logic.
    """

    def __init__(
        self,
        model: SystemModel,
        services: List[BaseService],
        event_dispatcher: EventDispatcher
    ):
        """
        Initialize system controller.
        
        Args:
            model: System model for state management
            services: List of services to manage (transport-agnostic)
            event_dispatcher: Event dispatcher for inter-service communication
        """
        # Initialize base model
        self._model = model
        
        # Initialize base controller with services list
        super().__init__(
            services=services,
            event_dispatcher=event_dispatcher
        )
        
        # Subscribe to domain events (input)
        self._dispatcher.subscribe("tank.level", self._on_tank_level_event)
        self._dispatcher.subscribe("wcs.status", self._on_wcs_status_event)

    async def _on_start(self) -> None:
        """Hook called before services start."""
        logger.info("SystemController started - transport agnostic mode")
        
    async def _on_stop(self) -> None:
        """Hook called before services stop."""
        pass
    
    # ============ INPUT: Domain Events (from services) ============
    
    async def _on_tank_level_event(self, event: Event) -> None:
        """
        Handle tank level updates (transport-agnostic).
        Payload can come from MQTT, Serial, HTTP, etc.
        
        Args:
            event: Event with water level data (string or dict)
        """
        payload = event.payload
        self._process_tank_level(payload)
    
    async def _on_wcs_status_event(self, event: Event) -> None:
        """
        Handle WCS status updates (valve position confirmations, etc.)
        
        Args:
            event: Event with WCS status data
        """
        data = event.payload
        logger.info(f"WCS status: {data}")
        # TODO: Update model with valve position, system state, etc.

    # ============ Business Logic ============
    
    def _process_tank_level(self, payload: str) -> None:
        """
        Process tank level reading and trigger actions.
        Content-agnostic: handles JSON dict, JSON number, or plain text.
        
        Args:
            payload: Water level data (any format)
        """
        try:
            # Try JSON format first
            data = json.loads(payload)
            
            # Check if it's a dict with level/timestamp or just a number
            if isinstance(data, dict):
                # JSON object format: {"level": 45.23, "timestamp": 1234567890}
                validated = TankLevelPayload(**data)
                logger.info(f"Received water level: {validated.level}, timestamp: {validated.to_datetime()}")
                self._model.add_level_reading(
                    LevelReading(water_level=validated.level, timestamp=validated.to_datetime())
                )
            elif isinstance(data, (int, float)):
                # JSON number format: 45.23
                timestamp = datetime.now()
                logger.info(f"Received water level (JSON number): {data}, using current time")
                self._model.add_level_reading(
                    LevelReading(water_level=float(data), timestamp=timestamp)
                )
            else:
                logger.error(f"Unexpected JSON type: {type(data)}")
            
        except json.JSONDecodeError:
            # Plain text format: just the level value
            try:
                level = float(payload.strip())
                timestamp = datetime.now()
                logger.info(f"Received water level (plain text): {level}, using current time")
                self._model.add_level_reading(
                    LevelReading(water_level=level, timestamp=timestamp)
                )
            except ValueError:
                logger.error(f"Invalid plain text level: {payload}")
                
        except ValidationError as e:
            logger.error(f"Invalid JSON structure: {e.errors()}")
        except Exception as e:
            logger.exception(f"Failed to process tank level: {e}")

    # ============ OUTPUT: Command Events (to services) ============
    
    async def _set_valve_position(self, position: float) -> None:
        """
        Command: Set valve position.
        Transport-agnostic - any service can handle this.
        
        Args:
            position: Valve position percentage (0-100)
        """
        logger.info(f"Controller command: set valve to {position}%")
        await self._dispatcher.publish("valve.set", {"position": position})
    
    async def _set_alarm(self, active: bool) -> None:
        """
        Command: Set alarm state.
        
        Args:
            active: True to activate alarm, False to deactivate
        """
        logger.info(f"Controller command: set alarm {'ON' if active else 'OFF'}")
        await self._dispatcher.publish("alarm.set", {"active": active})
    
    async def _request_system_status(self) -> None:
        """
        Command: Request current system status from WCS.
        """
        logger.debug("Controller command: request system status")
        await self._dispatcher.publish("system.status.request", {})
